import tkinter as tk
from tkinter import ttk, messagebox
import json
import os
from math import sqrt
import random

# Ensure correct working directory
os.chdir(os.path.dirname(os.path.abspath(__file__)))
JSON_FILE = "train_data.json"


class TrainModelTestUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Train Model Test UI - Imperial Units")
        self.geometry("750x900")

        # Load existing JSON
        self.data = self.load_json()
        self.inputs = self.data.get("inputs", {})
        self.specs = self.data.get("specs", {})
        self.outputs = self.data.get("outputs", {})

        # === Title ===
        ttk.Label(
            self,
            text="Train Model Input/Output Testing Interface (Imperial Units)",
            font=("Arial", 14, "bold")
        ).pack(pady=10)

        # === Input Frame ===
        input_frame = ttk.LabelFrame(self, text="Inputs (Editable Fields - Imperial Units)")
        input_frame.pack(fill="both", expand=True, padx=15, pady=10)

        self.entries = {}
        # Covers all inputs defined in your Imperial JSON
        for key, label in [
            ("commanded_power_hp", "Commanded Power (hp)"),
            ("authority_yds", "Authority (yds)"),
            ("commanded_speed_mph", "Commanded Speed (mph)"),
            ("speed_limit_mph", "Speed Limit (mph)"),
            ("beacon_data", "Beacon Data (Block/Next Station)"),
            ("passengers_boarding", "Passengers Boarding"),
            ("crew_count", "Crew Count"),
            ("emergency_brake", "Emergency Brake (True/False)")
        ]:
            self.create_entry(input_frame, key, label)

        ttk.Button(
            self,
            text="Update Inputs & Compute Outputs",
            command=self.run_simulation
        ).pack(pady=10)

        # === Output Frame ===
        output_frame = ttk.LabelFrame(self, text="Outputs (Generated by Train Model - Imperial Units)")
        output_frame.pack(fill="both", expand=True, padx=15, pady=10)

        self.output_labels = {}
        # Include all outputs (Imperial)
        for key in [
            "velocity_mph",
            "acceleration_ftps2",
            "position_yds",
            "authority_yds",
            "eta_s",
            "current_station",
            "next_station",
            "passengers_boarding",
            "passengers_disembarking",
            "passengers_onboard"
        ]:
            lbl = ttk.Label(output_frame, text=f"{key}: --")
            lbl.pack(anchor="w", padx=10, pady=2)
            self.output_labels[key] = lbl

        ttk.Label(
            self,
            text="* Results are automatically written back to train_data.json *",
            foreground="gray"
        ).pack(pady=5)

    # === Entry builder ===
    def create_entry(self, parent, key, label):
        frame = ttk.Frame(parent)
        frame.pack(fill="x", padx=10, pady=6)
        ttk.Label(frame, text=label, width=35, anchor="w").pack(side="left")
        entry = ttk.Entry(frame)
        entry.pack(side="right", fill="x", expand=True)
        entry.insert(0, str(self.inputs.get(key, "")))
        self.entries[key] = entry

    # === JSON Loader ===
    def load_json(self):
        if not os.path.exists(JSON_FILE):
            messagebox.showerror("Error", f"{JSON_FILE} not found. Please run train_model_ui.py first.")
            self.destroy()
            return {}
        with open(JSON_FILE, "r") as f:
            return json.load(f)

    # === Main Simulation ===
    def run_simulation(self):
        """Updates JSON inputs and computes consistent outputs."""
        try:
            # Update input values
            for key, entry in self.entries.items():
                val = entry.get().strip()
                if val.lower() in ["true", "false"]:
                    self.inputs[key] = val.lower() == "true"
                else:
                    try:
                        self.inputs[key] = float(val)
                    except ValueError:
                        self.inputs[key] = val

            self.data["inputs"] = self.inputs

            # Compute outputs (simplified but consistent with main UI)
            outputs = self.compute_outputs()
            self.data["outputs"] = outputs

            # Save to JSON
            with open(JSON_FILE, "w") as f:
                json.dump(self.data, f, indent=4)

            # Update UI
            for key, val in outputs.items():
                self.output_labels[key].config(text=f"{key}: {val}")

            messagebox.showinfo("Success", "Simulation executed and JSON updated successfully!")

        except Exception as e:
            messagebox.showerror("Error", f"Simulation failed: {e}")

    # === Output computation (Imperial units) ===
    def compute_outputs(self):
        """Compute basic outputs consistent with Imperial-unit train_model_ui logic."""
        power_hp = float(self.inputs.get("commanded_power_hp", 0))
        authority_yds = float(self.inputs.get("authority_yds", 0))
        passengers_boarding = float(self.inputs.get("passengers_boarding", 0))
        emergency = self.inputs.get("emergency_brake", False)

        # Specs
        mass_lbs = float(self.specs.get("mass_lbs", 90100))
        max_accel_ftps2 = float(self.specs.get("max_accel_ftps2", 1.64))
        emergency_brake_ftps2 = float(self.specs.get("emergency_brake_ftps2", -8.86))

        # Simplified motion model (Imperial)
        # Convert horsepower to ft·lbf/s: 1 hp = 550 ft·lbf/s
        velocity_ftps = sqrt(max((power_hp * 550) / (mass_lbs * 2), 0))
        velocity_mph = velocity_ftps * 0.681818  # ft/s → mph
        acceleration_ftps2 = max_accel_ftps2 if not emergency else emergency_brake_ftps2

        position_yds = (velocity_ftps * 5) / 3.0  # arbitrary motion scaling
        authority_left = max(authority_yds - position_yds, 0)

        # Passenger updates
        passengers_disembarking = random.randint(0, int(max(passengers_boarding * 0.1, 1)))
        passengers_onboard = max(passengers_boarding - passengers_disembarking, 0)

        # Station and ETA
        current_station = "Downtown" if position_yds < 547 else "Midtown"
        next_station = "Midtown" if position_yds < 547 else "Uptown"
        velocity_yds_per_s = (velocity_mph * 1760) / 3600
        eta = round(authority_left / max(velocity_yds_per_s, 0.1), 1)

        return {
            "velocity_mph": round(velocity_mph, 2),
            "acceleration_ftps2": round(acceleration_ftps2, 2),
            "position_yds": round(position_yds, 1),
            "authority_yds": round(authority_left, 1),
            "eta_s": eta,
            "current_station": current_station,
            "next_station": next_station,
            "passengers_boarding": passengers_boarding,
            "passengers_disembarking": passengers_disembarking,
            "passengers_onboard": passengers_onboard
        }


if __name__ == "__main__":
    app = TrainModelTestUI()
    app.mainloop()
