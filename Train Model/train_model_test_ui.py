import tkinter as tk
from tkinter import ttk
import json
import os

# === File Paths ===
TRACK_TO_TRAIN_FILE = "../Track_Model/track_model_to_Train_Model.json"
TRAIN_DATA_FILE = "train_data.json"

os.chdir(os.path.dirname(os.path.abspath(__file__)))


# === Train Model Core (no specs) ===
class TrainModel:
    def __init__(self):
        """Core physics and dynamic state."""
        self.velocity_mph = 0.0
        self.acceleration_ftps2 = 0.0
        self.position_yds = 0.0
        self.authority_yds = 0.0
        self.dt = 0.5

    def update(self, commanded_speed, commanded_authority):
        """Simple kinematic update simulation."""
        target_speed_ftps = commanded_speed * 1.46667
        accel = (target_speed_ftps - (self.velocity_mph * 1.46667)) / 2.0
        # Clamp acceleration to realistic range
        self.acceleration_ftps2 = max(min(accel, 1.64), -3.94)

        delta_v_ftps = self.acceleration_ftps2 * self.dt
        delta_v_mph = delta_v_ftps * 0.681818
        self.velocity_mph = max(self.velocity_mph + delta_v_mph, 0)
        delta_x_ft = (self.velocity_mph / 0.681818) * self.dt
        delta_x_yds = delta_x_ft / 3.0
        self.position_yds += delta_x_yds
        self.authority_yds = commanded_authority

        return {
            "velocity_mph": self.velocity_mph,
            "acceleration_ftps2": self.acceleration_ftps2,
            "position_yds": self.position_yds,
            "authority_yds": self.authority_yds
        }


# === Train Model Test UI (Integrated + Editable) ===
class TrainModelTestUI(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("Train Model Test UI - Integrated with Track Model")
        self.geometry("850x800")

        self.model = TrainModel()
        self.inputs = {}
        self.outputs = {}

        self.create_ui()
        self.load_from_track_model()
        self.update_loop()

    # ---------- UI Layout ----------
    def create_ui(self):
        """Builds all UI panels."""
        title = ttk.Label(
            self,
            text="Train Model Input/Output Testing Interface (Integrated Mode)",
            font=("Segoe UI", 12, "bold")
        )
        title.pack(pady=10)

        # === INPUT FRAME ===
        input_frame = ttk.LabelFrame(self, text="Inputs (Editable Fields - From Track Model)")
        input_frame.pack(fill="x", padx=15, pady=10)

        self.input_fields = {}
        input_labels = [
            "Commanded Speed (mph)",
            "Commanded Authority (yds)",
            "Speed Limit (mph)",
            "Side Door (Left/Right)",
            "Current Station",
            "Next Station"
        ]

        for label in input_labels:
            frame = ttk.Frame(input_frame)
            frame.pack(fill="x", pady=3)
            ttk.Label(frame, text=label, width=25).pack(side="left", padx=5)
            entry = ttk.Entry(frame, width=20)
            entry.pack(side="left")
            self.input_fields[label] = entry

        ttk.Button(
            self,
            text="Update Inputs & Compute Outputs",
            command=self.compute_outputs
        ).pack(pady=8)

        # === OUTPUT FRAME ===
        output_frame = ttk.LabelFrame(self, text="Outputs (Generated by Train Model - Imperial Units)")
        output_frame.pack(fill="both", expand=True, padx=15, pady=10)
        self.output_box = tk.Text(output_frame, height=18, wrap="word")
        self.output_box.pack(fill="both", expand=True, padx=5, pady=5)

    # ---------- File Reading ----------
    def load_from_track_model(self):
        """Load latest Track Model data and fill the UI fields."""
        try:
            with open(TRACK_TO_TRAIN_FILE, "r") as f:
                data = json.load(f)
            block = data.get("block", {})
            beacon = data.get("beacon", {})

            # Fill UI input fields automatically
            self.input_fields["Commanded Speed (mph)"].delete(0, "end")
            self.input_fields["Commanded Speed (mph)"].insert(0, str(block.get("commanded speed", 0)))

            self.input_fields["Commanded Authority (yds)"].delete(0, "end")
            self.input_fields["Commanded Authority (yds)"].insert(0, str(block.get("commanded authority", 0)))

            self.input_fields["Speed Limit (mph)"].delete(0, "end")
            self.input_fields["Speed Limit (mph)"].insert(0, str(beacon.get("speed limit", 30)))

            self.input_fields["Side Door (Left/Right)"].delete(0, "end")
            self.input_fields["Side Door (Left/Right)"].insert(0, beacon.get("side_door", "Right"))

            self.input_fields["Current Station"].delete(0, "end")
            self.input_fields["Current Station"].insert(0, beacon.get("current station", "Unknown"))

            self.input_fields["Next Station"].delete(0, "end")
            self.input_fields["Next Station"].insert(0, beacon.get("next station", "Unknown"))

        except Exception as e:
            print(f"[Error] Cannot read Track Model JSON: {e}")

    # ---------- Compute Outputs ----------
    def compute_outputs(self):
        """Run physics model and display results."""
        try:
            commanded_speed = float(self.input_fields["Commanded Speed (mph)"].get())
            commanded_authority = float(self.input_fields["Commanded Authority (yds)"].get())
            speed_limit = float(self.input_fields["Speed Limit (mph)"].get())
            side_door = self.input_fields["Side Door (Left/Right)"].get()
            current_station = self.input_fields["Current Station"].get()
            next_station = self.input_fields["Next Station"].get()
        except ValueError:
            print("[Error] Invalid numeric input.")
            return

        # Update physics outputs
        physics = self.model.update(commanded_speed, commanded_authority)

        # Compute door and station outputs
        left_door_open = side_door.lower() == "left"
        right_door_open = side_door.lower() == "right"

        outputs = {
            **physics,
            "speed_limit_mph": speed_limit,
            "side_door": side_door,
            "current_station": current_station,
            "next_station": next_station,
            "left_door_open": left_door_open,
            "right_door_open": right_door_open
        }

        self.display_outputs(outputs)

    # ---------- Output Display ----------
    def display_outputs(self, outputs):
        """Render outputs in the text box."""
        self.output_box.delete("1.0", "end")
        for key, value in outputs.items():
            self.output_box.insert("end", f"{key}: {value}\n")

    # ---------- Auto Refresh ----------
    def update_loop(self):
        """Auto-refresh Track Model inputs every 0.5s."""
        self.load_from_track_model()
        self.after(500, self.update_loop)


if __name__ == "__main__":
    app = TrainModelTestUI()
    app.mainloop()
