import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import json
import pandas as pd
import os
import re
from track_model_UI import TrackModelUI
import threading


class TrackBuilder(tk.Tk):
    def __init__(self):
        super().__init__()
        
        self.title("Track Model Test UI")
        self.geometry("780x370")
        self.resizable(False, False)

        # === LINE AND BLOCK SELECTION === #
        selection_frame = ttk.LabelFrame(self, text="Select Line and Block")
        selection_frame.pack(fill="x", padx=10, pady=(10, 2))

        ttk.Label(selection_frame, text="Line:").pack(side="left", padx=5, pady=5)
        self.line_selection = ttk.Combobox(selection_frame, state="readonly", width=15)
        self.line_selection.pack(side="left", padx=5, pady=5)

        ttk.Label(selection_frame, text="Block:").pack(side="left", padx=5, pady=5)
        self.block_selection = ttk.Combobox(selection_frame, state="readonly", width=15)
        self.block_selection.pack(side="left", padx=5, pady=5)

        # === FORCE INPUTS === #
        input_frame = ttk.LabelFrame(self, text="Force Inputs")
        input_frame.pack(fill="both", expand=False, padx=10, pady=(5, 2))

        for i in range(2):
            input_frame.columnconfigure(i, weight=1)
        current_row = 0

        def make_entry(label):
            nonlocal current_row
            ttk.Label(input_frame, text=label).grid(
                row=current_row // 2,
                column=(current_row % 2) * 2,
                sticky="w",
                padx=5,
                pady=5,
            )
            entry = ttk.Entry(input_frame, width=20)
            entry.grid(
                row=current_row // 2,
                column=(current_row % 2) * 2 + 1,
                padx=5,
                pady=5,
            )
            current_row += 1
            return entry

        # === ENTRIES === #
        self.speed_entry = make_entry("Commanded Speed (mph)")
        self.authority_entry = make_entry("Commanded Authority (yards)")
        self.temp_entry = make_entry("Environmental Temperature (Â°F)")
        self.passengers_disembark_entry = make_entry("Passengers Disembarking")
        self.switch_position_entry = make_entry("Switch Position")

        # === LIGHT AND GATE DROPDOWNS === #
        ttk.Label(input_frame, text="Light").grid(row=current_row // 2, column=(current_row % 2) * 2, sticky="w", padx=5, pady=5)
        self.light_entry = ttk.Combobox(input_frame, values=["Red", "Yellow", "Green"], state="readonly", width=18)
        self.light_entry.grid(row=current_row // 2, column=(current_row % 2) * 2 + 1, padx=5, pady=5)
        current_row += 1

        ttk.Label(input_frame, text="Gate").grid(row=current_row // 2, column=(current_row % 2) * 2, sticky="w", padx=5, pady=5)
        self.gate_entry = ttk.Combobox(input_frame, values=["Open", "Closed"], state="readonly", width=18)
        self.gate_entry.grid(row=current_row // 2, column=(current_row % 2) * 2 + 1, padx=5, pady=5)
        current_row += 1

        # === FAILURES === #
        failure_frame = ttk.LabelFrame(self, text="Failure Modes")
        failure_frame.pack(fill="x", expand=False, padx=10, pady=(5, 5))
        self.failure_vars = {
            "power": tk.BooleanVar(value=False),
            "circuit": tk.BooleanVar(value=False),
            "broken": tk.BooleanVar(value=False),
        }
        for label in self.failure_vars:
            ttk.Checkbutton(
                failure_frame,
                text=label.replace("_", " ").title(),
                variable=self.failure_vars[label],
            ).pack(anchor="w", padx=15, pady=2)

        # === BUTTONS === #
        button_frame = ttk.Frame(self)
        button_frame.pack(pady=(0, 10))
        ttk.Button(
            button_frame,
            text="Upload Track Layout File",
            command=self.upload_schedule,
            width=25,
        ).grid(row=0, column=0, padx=10)
        ttk.Button(
            button_frame, text="Update Inputs", command=self.simulate, width=20
        ).grid(row=0, column=1, padx=10)

    # === INFRASTRUCTURE HELPERS === #
    def extract_station(self, value):
        text = str(value).upper()
        match = re.search(r"STATION[:;]?\s*([A-Z\s]+)", text)
        return match.group(1).strip().title() if match else "N/A"

    def extract_branching(self, value):
        text = str(value).upper()
        if "YARD" in text:
            return "To/From Yard"
        elif "SWITCH" in text:
            return "Yes"
        return "No"

    # === UPLOAD (DYNAMIC LINE DETECTION, NO OVERWRITE) === #
    def upload_schedule(self):
        if os.path.exists("track_model_static.json"):
            try:
                with open("track_model_static.json", "r") as f:
                    existing = json.load(f)
                if existing.get("static_data"):
                    messagebox.showinfo("Info", "Track layout already loaded for this session.")
                    return
            except Exception:
                pass

        file_path = filedialog.askopenfilename(
            title="Select Track Layout File",
            filetypes=[("Excel Files", "*.xlsx *.xls")],
        )
        if not file_path:
            messagebox.showerror("No File Selected", "Please select a valid file.")
            return

        try:
            xl = pd.ExcelFile(file_path)
            sheet_names = xl.sheet_names
            available_lines = [
                name.replace(" Line", "").strip()
                for name in sheet_names
                if name.endswith(" Line")
            ]

            self.line_selection["values"] = available_lines
            if available_lines:
                self.line_selection.current(0)
            else:
                self.line_selection.set("")

            all_lines_data = {}
            for line in available_lines:
                df = pd.read_excel(file_path, sheet_name=f"{line} Line")
                df = df.fillna("N/A")
                df["Station"] = df["Infrastructure"].apply(self.extract_station)
                df["Crossing"] = df["Infrastructure"].apply(
                    lambda x: "Yes" if "CROSSING" in str(x).upper() else "No"
                )
                df["Branching"] = df["Infrastructure"].apply(self.extract_branching)
                all_lines_data[line] = df.to_dict(orient="records")

            data = {"static_data": all_lines_data}

            with open("track_model_static.json", "w") as f:
                json.dump(data, f, indent=4)

            selected_line = self.line_selection.get()
            self.static_data = all_lines_data.get(selected_line, [])
            blocks = [
                f"{r['Section']}{int(float(r['Block Number']))}"
                for r in self.static_data
                if str(r["Block Number"]).replace(".", "", 1).isdigit()
            ]
            self.block_selection["values"] = blocks
            if blocks:
                self.block_selection.current(0)

            messagebox.showinfo("Success", "Track layout successfully loaded.")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to process Excel file:\n{e}")

    # === VALIDATION === #
    def validate_inputs(self):
        try:
            selected_line = self.line_selection.get()
            selected_block = self.block_selection.get()
            if not selected_line or not selected_block:
                messagebox.showerror("Missing Selection", "Please select both a line and block first.")
                return False

            with open("track_model_static.json", "r") as f:
                static = json.load(f)
            records = static.get("static_data", {}).get(selected_line, [])

            block_data = next(
                (r for r in records if f"{r['Section']}{int(float(r['Block Number']))}" == selected_block),
                None,
            )
            if not block_data:
                messagebox.showerror("Missing Data", "No data found for selected block.")
                return False

            limit_kmh = float(block_data.get("Speed Limit (Km/Hr)", 0))
            limit_mph = round(limit_kmh * 0.621371, 2)
            block_length_m = float(block_data.get("Block Length (m)", 0))
            block_length_yd = round(block_length_m * 1.09361, 2)

            def get_int(entry, min_val=None, max_val=None):
                val = entry.get().strip()
                if val == "":
                    return None
                num = int(float(val))
                if (min_val is not None and num < min_val) or (
                    max_val is not None and num > max_val
                ):
                    raise ValueError(f"Value {num} out of bounds [{min_val}, {max_val}]")
                return num

            get_int(self.speed_entry, 0, limit_mph)
            get_int(self.authority_entry, 0, block_length_yd)
            get_int(self.temp_entry, -50, 150)
            get_int(self.passengers_disembark_entry, 0, 412)

            return True
        except ValueError as e:
            messagebox.showerror("Invalid Input", str(e))
            return False
        except FileNotFoundError:
            messagebox.showerror("Missing File", "Please upload a track layout file first.")
            return False

    # === SIMULATE (WRITE TO STATE FILE) === #
    def simulate(self):
        if not self.validate_inputs():
            return

        selected_line = self.line_selection.get()
        selected_block = self.block_selection.get()

        try:
            with open("track_model_state.json", "r") as f:
                data = json.load(f)
        except (FileNotFoundError, json.JSONDecodeError):
            data = {}

        if selected_line not in data:
            data[selected_line] = {}
        if selected_block not in data[selected_line]:
            data[selected_line][selected_block] = {}

        existing = data[selected_line][selected_block]

        disembarking = self.passengers_disembark_entry.get().strip()
        if disembarking == "":
            disembarking = existing.get("station", {}).get("disembarking", 0)
        else:
            disembarking = int(float(disembarking))

        temperature = self.temp_entry.get().strip()
        if temperature == "":
            temperature = existing.get("environment", {}).get("temperature", 0)
        else:
            temperature = int(float(temperature))

        switch_position = self.switch_position_entry.get().strip()
        if switch_position == "":
            switch_position = existing.get("block", {}).get("switch_position", "N/A")

        light = self.light_entry.get().strip()
        if light == "":
            light = existing.get("block", {}).get("light", "N/A")

        gate = self.gate_entry.get().strip()
        if gate == "":
            gate = existing.get("block", {}).get("gate", "N/A")

        commanded_speed = self.speed_entry.get().strip()
        if commanded_speed == "":
            commanded_speed = existing.get("commanded", {}).get("speed", 0)
        else:
            commanded_speed = int(float(commanded_speed))

        commanded_authority = self.authority_entry.get().strip()
        if commanded_authority == "":
            commanded_authority = existing.get("commanded", {}).get("authority", 0)
        else:
            commanded_authority = int(float(commanded_authority))

        failures = {k: v.get() for k, v in self.failure_vars.items()}

        if failures.get("broken"):
            commanded_speed = 0
            commanded_authority = 0

        block = {
            "switch_position": switch_position,
            "light": light,
            "gate": gate
        }
        environment = {"temperature": temperature}
        station = {"disembarking": disembarking}
        commanded = {"speed": commanded_speed, "authority": commanded_authority}

        data[selected_line][selected_block] = {
            "block": block,
            "environment": environment,
            "failures": failures,
            "station": station,
            "commanded": commanded,
        }

        with open("track_model_state.json", "w") as f:
            json.dump(data, f, indent=4)

        messagebox.showinfo("Update Successful", f"Inputs updated for {selected_line} - {selected_block}.")


if __name__ == "__main__":
    app = TrackBuilder()
    app.mainloop()

    if os.path.exists("track_model_static.json"):
        with open("track_model_static.json", "w") as f:
            json.dump({}, f, indent=4)
